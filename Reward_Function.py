import numpy as np

class RewardCalculator:
    """
    Calculates the reward for the active suspension RL agent.

    This class implements the multi-objective reward function that balances
    ride comfort, road handling, energy regeneration, and control effort.
    The weights for each objective can be tuned during initialization to
    prioritize different performance aspects (e.g., comfort vs. energy saving).
    """
    def __init__(self, w_comfort=1.0, w_holding=1.0, w_regen=0.001, w_effort=1e-6):
        """
        Initializes the reward calculator with weights for each objective.

        The default weights are chosen as a starting point and will likely
        need tuning. The weights are scaled to bring the penalties and
        rewards to a comparable order of magnitude.

        Args:
            w_comfort (float): Weight for the ride comfort penalty (body acceleration).
            w_holding (float): Weight for the road holding penalty (tire deflection).
            w_regen (float): Weight for the energy regeneration reward.
            w_effort (float): Weight for the control effort penalty (actuator force).
        """
        self.w_comfort = w_comfort
        self.w_holding = w_holding
        self.w_regen = w_regen
        self.w_effort = w_effort

    def calculate_reward(self, p_regen, x_s_ddot, x_u, x_g, u):
        """
        Calculates the total reward for a given state and action.

        Args:
            p_regen (float): The power regenerated by the actuator (W).
            x_s_ddot (float): The sprung mass (body) acceleration (m/s^2).
            x_u (float): The unsprung mass (wheel) displacement (m).
            x_g (float): The road profile displacement (m).
            u (float): The control force applied by the actuator (N).

        Returns:
            float: The total calculated reward for the current time step.
        """
        # 1. Reward for Energy Regeneration (Positive Reward)
        # Directly proportional to the watts of power harvested.
        reward_energy = self.w_regen * p_regen

        # 2. Penalty for Discomfort (Negative Reward)
        # Penalizes the square of the body acceleration to promote a smooth ride.
        penalty_comfort = self.w_comfort * (x_s_ddot ** 2)

        # 3. Penalty for Poor Handling (Negative Reward)
        # Penalizes the square of tire deflection to keep the wheel on the road.
        tire_deflection = x_u - x_g
        penalty_holding = self.w_holding * (tire_deflection ** 2)
        
        # 4. Penalty for Control Effort (Negative Reward)
        # Penalizes the square of the actuator force to encourage efficiency.
        penalty_effort = self.w_effort * (u ** 2)

        # Calculate the total reward
        total_reward = reward_energy - penalty_comfort - penalty_holding - penalty_effort

        return total_reward

